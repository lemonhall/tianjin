0、TCP握手三部曲
==============
==>SYN
<==SYN,ACK
===>ACK

方法1： env LANG=en_US.utf8 任意的gcc命令和参数
方法2： export LC_ALL=C 可以让这个终端暂时改成英文的。

1、第一步，客户端向服务端请求
========================
===>
seq:573406793:573407026

	573407026
	573406793
-
--------------
		  233
明白过，原来573407026就是seq+包的length

ack:1065430037

13:34:46.466406 IP 1.80.126.29.10997 > 220.181.49.164.http: Flags [P.], seq 573406793:573407026, ack 1065430037, win 8211, options [nop,nop,TS val 1102283585 ecr 415088180], length 233

1.1、应该怎样伪造呢？
=================
第一次发包（因为我们的包较小，要不要发空包，还要实验一下，查一下文献）：

		伪造包的seq值：将GET请求包的ack填入伪造包的seq
		伪造包的ack值：请求包的seq+caplen值

第二次发包（实际上就已经是FIN包了.....）

		伪造包的seq值：上一个包的seq+caplen值=请求包的ack+内容包的length值
		伪造包的ack值：仍旧是请求包的seq+caplen值

关于Flags
=========

第一版的JAVA程序里，一共发了三次包
TCPPacket
			urg  ,  ack,psh  ,  rst   ,syn   ,fin  ,rsv1  ,rsv2
----------------------------------------------------------------
第一次空包  ：false, true,false, false, false, false, false, false		
第二次内容  ：false, true,true , false, false, false, false, false
第三次空包  ：false, true,false, false, false, true, false, false


好了，我们总结一下：
应答包的seq值是递增的，第一次取请求包的th_ack值，如果要多次应答，则每一次的seq值都是上一个包的seq+length值.....

至于应答包的ack值？那个取请求包的seq+length就可以了

在这个会话期间，应答包的ack值没有必要再次计算....



2、第二步，服务器应答一个空包
========================
<===
seq:没有seq值
空包的ack:等于上一步的seq的尾部:573407026

13:34:46.466444 IP 220.181.49.164.http > 1.80.126.29.10997: Flags [.], ack 573407026, win 122, options [nop,nop,TS val 415088201 ecr 1102283585], length 0
E..4.]@.@.....1..P~..P*.?.,."-.2...z.F.....
...IA..A

2.1、伪造失败的包
===============
我们伪造失败的包呢，没有赶在服务器应答之前发空包
这是第一个失败
seq:1065430037这个倒是生成的对的，之后的那一串:1065430503到底是什么？
ack:707624521这则是一个完全失败的数字，应该是从第一步请求的seq的尾部取573407026

	1065430503
	1065430037
-
--------------
		   466
尾部的这个值只是计算出来的，嗯！

safari访问audits.wukong.com的packet.length=355
421-355
393-353

13:34:46.468393 IP 220.181.49.164.http > 1.80.126.29.10997: Flags [.], seq 1065430037:1065430503, ack 707624521, win 37013, length 466
E....9..@.....1..P~..P*.?.,.*-~IP...R&..HTTP/1.1 200 OK

3、第三步，服务器发送实际内容
========================
<===
seq:第一步的ack:一个未知的值(1065431465)
ack:第一步客户端请求的尾部:573407026

13:34:46.471578 IP 220.181.49.164.http > 1.80.126.29.10997: Flags [.], seq 1065430037:1065431465, ack 573407026, win 122, options [nop,nop,TS val 415088205 ecr 1102283585], length 1428
E....^@.@.....1..P~..P*.?.,."-.2...z.......
...MA..AHTTP/1.1 200 OK


4、第四步，因包的内容过大所以，所以要发很多个包
=======================================
<===
seq:上一步的seq的尾部，那个未知的值(1065431465)：一个不知道怎么计算出来的值
ack:第一步客户端请求的尾部:573407026

13:34:46.471587 IP 220.181.49.164.http > 1.80.126.29.10997: Flags [P.], seq 1065431465:1065432739, ack 573407026, win 122, options [nop,nop,TS val 415088206 ecr 1102283585], length 1274
E...._@.@.....1..P~..P*.?.1."-.2...z.......
...NA..Ain input[type="text"],

5、第五步，空包结尾？
================
<====
seq:上一步那个不知道怎么计算出来的值
ack:第一步的seq的尾部

13:34:46.471630 IP 220.181.49.164.http > 1.80.126.29.10997: Flags [F.], seq 1065432739, ack 573407026, win 122, options [nop,nop,TS val 415088206 ecr 1102283585], length 0
E..4.`@.@.....1..P~..P*.?.6."-.2...z	......
...NA..A
